/**
 * Generated by Gas3 v2.3.2 (Granite Data Services).
 *
 * NOTE: this file is only generated if it does not exist. You may safely put
 * your custom code here.
 */

package com.photodispatcher.model.mysql.entities {
	import com.photodispatcher.context.Context;
	import com.photodispatcher.print.LabGeneric;
	import com.photodispatcher.util.GridUtil;
	import com.photodispatcher.util.StrUtil;
	
	import flash.filesystem.File;
	import flash.globalization.DateTimeStyle;
	
	import mx.collections.ArrayCollection;
	import mx.collections.ArrayList;
	
	import spark.components.gridClasses.GridColumn;
	import spark.formatters.DateTimeFormatter;

    [Bindable]
    [RemoteClass(alias="com.photodispatcher.model.mysql.entities.PrintGroup")]
    public class PrintGroup extends PrintGroupBase {
		public static const PDF_FILENAME_COVERS:String='oblogka';
		public static const PDF_FILENAME_SHEETS:String='blok';
		public static const SUBFOLDER_PRINT:String='print';
		
		public static function sourceIdFromId(pgId:String):int{
			var arr:Array;
			if(!pgId) return 0;
			arr=pgId.split('_');
			if(arr && arr.length>0)	return int(arr[0]);
			return 0;
		}
		
		public static function orderIdFromId(pgId:String):String{
			var arr:Array;
			var result:String='';
			if(!pgId) return '';
			
			arr=pgId.split('_');
			if(arr && arr.length>1){
				result=arr[0]+'_'+arr[1];
			}else{
				result=pgId; 
			}
			return result;
		}

		public static function gridColumns(withLab:Boolean=false):ArrayList{
			var a:Array=baseGridColumns();
			var col:GridColumn;
			if(!a) return null;
			if(withLab){
				col= new GridColumn('lab_name'); col.headerText='Лаборатория'; col.width=80;
				a.unshift(col);
			}
			return new ArrayList(a);
		}
		
		private static function baseGridColumns():Array{
			var result:Array= [];
			
			var col:GridColumn= new GridColumn('source_name'); col.headerText='Источник'; col.width=70; result.push(col);
			//col= new GridColumn('order_id'); col.headerText='Id Заказа'; result.addItem(col);
			col= new GridColumn('id'); col.headerText='ID'; col.width=80; result.push(col);
			col= new GridColumn('state_name'); col.headerText='Статус'; col.width=95; result.push(col); 
			var fmt:DateTimeFormatter=new DateTimeFormatter(); fmt.dateStyle=fmt.timeStyle=DateTimeStyle.SHORT; 
			col= new GridColumn('state_date'); col.headerText='Дата статуса'; col.formatter=fmt;  col.width=110; result.push(col);
			col= new GridColumn('path'); col.headerText='Папка'; result.push(col);
			col= new GridColumn('width'); col.headerText='Ширина'; result.push(col);
			col= new GridColumn('height'); col.headerText='Длина'; result.push(col);
			col= new GridColumn('paper_name'); col.headerText='Бумага'; result.push(col);
			col= new GridColumn('frame_name'); col.headerText='Рамка'; result.push(col);
			col= new GridColumn('correction_name'); col.headerText='Коррекция'; result.push(col);
			col= new GridColumn('cutting_name'); col.headerText='Обрезка'; result.push(col);
			col= new GridColumn('book_type_name'); col.headerText='Тип книги'; result.push(col);
			col= new GridColumn('book_part_name'); col.headerText='Часть книги'; result.push(col);
			col= new GridColumn('is_pdf'); col.headerText='PDF'; col.labelFunction=GridUtil.booleanToLabel; result.push(col);
			col= new GridColumn('book_num'); col.headerText='Кол книг'; result.push(col);
			//col= new GridColumn('cover_name'); col.headerText='Обложка'; result.addItem(col);
			col= new GridColumn('prints'); col.headerText='Кол отпечатков'; result.push(col);
			return result;
		}
		
		public static function shortGridColumns():ArrayList{
			var result:Array= [];
			var col:GridColumn;
			
			col= new GridColumn('id'); col.headerText='ID'; col.width=85; result.push(col);
			col= new GridColumn('state_name'); col.headerText='Статус'; col.width=90; result.push(col); 
			var fmt:DateTimeFormatter=new DateTimeFormatter(); fmt.dateStyle=fmt.timeStyle=DateTimeStyle.SHORT; 
			col= new GridColumn('state_date'); col.headerText='Дата статуса'; col.formatter=fmt;  col.width=110; result.push(col);
			col= new GridColumn('lab_name'); col.headerText='Лаборатория'; col.width=70; result.push(col);
			col= new GridColumn('is_reprint'); col.headerText='Перепечатка'; col.labelFunction=GridUtil.booleanToLabel; result.push(col);
			col= new GridColumn('path'); col.headerText='Папка'; result.push(col);
			col= new GridColumn('width'); col.headerText='Ширина'; result.push(col);
			col= new GridColumn('height'); col.headerText='Длина'; result.push(col);
			col= new GridColumn('paper_name'); col.headerText='Бумага'; result.push(col);
			col= new GridColumn('frame_name'); col.headerText='Рамка'; result.push(col);
			col= new GridColumn('correction_name'); col.headerText='Коррекция'; result.push(col);
			col= new GridColumn('cutting_name'); col.headerText='Обрезка'; result.push(col);
			col= new GridColumn('book_type_name'); col.headerText='Тип книги'; result.push(col);
			col= new GridColumn('book_part_name'); col.headerText='Часть книги'; result.push(col);
			col= new GridColumn('is_pdf'); col.headerText='PDF'; col.labelFunction=GridUtil.booleanToLabel; result.push(col);
			col= new GridColumn('book_num'); col.headerText='Кол книг'; result.push(col);
			col= new GridColumn('prints'); col.headerText='Кол отпечатков'; result.push(col);
			return new ArrayList(result);
		}
		
		public static function reprintGridColumns():ArrayList{
			var result:Array= [];
			var col:GridColumn;
			
			col= new GridColumn('id'); col.headerText='ID'; col.width=85; result.push(col);
			col= new GridColumn('path'); col.headerText='Папка'; result.push(col);
			col= new GridColumn('width'); col.headerText='Ширина'; result.push(col);
			col= new GridColumn('height'); col.headerText='Длина'; result.push(col);
			col= new GridColumn('paper_name'); col.headerText='Бумага'; result.push(col);
			col= new GridColumn('frame_name'); col.headerText='Рамка'; result.push(col);
			col= new GridColumn('correction_name'); col.headerText='Коррекция'; result.push(col);
			col= new GridColumn('cutting_name'); col.headerText='Обрезка'; result.push(col);
			col= new GridColumn('book_type_name'); col.headerText='Тип книги'; result.push(col);
			col= new GridColumn('book_part_name'); col.headerText='Часть книги'; result.push(col);
			col= new GridColumn('is_pdf'); col.headerText='PDF'; col.labelFunction=GridUtil.booleanToLabel; result.push(col);
			col= new GridColumn('book_num'); col.headerText='Кол книг'; result.push(col);
			return new ArrayList(result);
		}

		
		public var bookTemplate:BookPgTemplate;
		public var butt:int=0;
		public var is_horizontal:Boolean;
		/**
		 * runtime
		 * post to lab (used in PrintManager) 
		 */
		public var destinationLab:LabGeneric;

		
		public function PrintGroup(){
			super.state=OrderState.PRN_WAITE_ORDER_STATE;
			state_date= new Date();
		}
		
		private var _prev_state:int;
		override public function set state(value:int):void{
			state_date= new Date();
			if(super.state != value){
				//save old valid state
				if(super.state>0) _prev_state=super.state;
				state_name= OrderState.getStateName(value);
			}
			super.state = value;
		}
		override public function get state():int{
			return super.state;
		}
		
		public function restoreState():void{
			if(_prev_state>0 && _prev_state!=state) state=_prev_state;
		}

		private var originalFiles:ArrayCollection;
		public function resetFiles(keep:Boolean=true):void{
			if(keep) originalFiles=files as ArrayCollection; 
			files=null;
		}
		
		public function restoreFiles():void{
			if(book_type!=0){ //only 4 books
				files=originalFiles;
				file_num=files?files.length:0;
			}
		}

		public function addFile(file:PrintGroupFile):void{
			if(!file) return;
			if(!files) files=new ArrayCollection();
			files.addItem(file);
			file_num=files.length;
		}

		public function key(srcType:int=SourceType.LAB_NORITSU,fullness:int=0):String{
			var sizeKey:String;
			switch(fullness){
				case 1:
					//no height 
					sizeKey=width.toString()+'_h'; 
					break;
				case 2:
					//no size at all 
					sizeKey='w_h'; 
					break;
				default:
					//full
					sizeKey=width.toString()+'_'+height.toString(); 
			}
			var result:String;
			switch(srcType){
				case SourceType.LAB_FUJI:
					//SourceType.LAB_FUJI - short key, exlude correction & cutting 
					result=sizeKey+'_'+paper.toString()+'_'+frame.toString(); 
					break;
				case SourceType.LAB_PLOTTER:
					//SourceType.LAB_PLOTTER - short key, exlude correction, cutting & frame 
					result=sizeKey+'_'+paper.toString(); 
					break;
				case SourceType.LAB_XEROX:
					//SourceType.LAB_XEROX - short key, include w/h/pape/duplex
					result=sizeKey+'_'+paper.toString()+'_'+is_duplex.toString(); 
					break;
				case SourceType.LAB_NORITSU_NHF:
					//include w/h
					result=sizeKey; 
					break;
				default:
					//full key (SourceType.LAB_NORITSU or any)
					result=sizeKey+'_'+paper.toString()+'_'+frame.toString()+'_'+correction.toString()+'_'+cutting.toString(); 
					break;
			}
			return result;
		}

		public function clone():PrintGroup{
			var res:PrintGroup=new PrintGroup();
			
			res.order_id=order_id;
			res.sub_id=sub_id;
			
			res.width=width;
			res.height=height;
			
			res.paper=paper;
			res.paper_name=paper_name;
			
			res.frame=frame;
			res.frame_name=frame_name;
			
			res.correction=correction;
			res.correction_name=correction_name;
			
			res.cutting=cutting;
			res.cutting_name=cutting_name;
			
			res.path=path;
			
			res.book_type=book_type;
			res.book_type_name=book_type_name;
			
			res.book_num=book_num;
			
			res.book_part=book_part;
			res.book_part_name=book_part_name;
			
			res.is_pdf=is_pdf;
			res.is_duplex=is_duplex;
			return res;
		}

		public function toRaw():Object{
			var raw:Object= new Object;
			raw.id=id;
			raw.order_id=order_id;
			raw.state=state;
			//raw.state_date=state_date;
			raw.width=width;
			raw.height=height;
			raw.paper=paper;
			raw.frame=frame;
			raw.correction=correction;
			raw.cutting=cutting;
			raw.path=path;
			raw.file_num=file_num;
			raw.book_type=book_type;
			raw.book_part=book_part;
			raw.book_num=book_num;
			raw.is_pdf=is_pdf?1:0;
			raw.is_duplex=is_duplex?1:0;
			raw.is_horizontal=is_horizontal?1:0;
			raw.butt=butt;
			raw.pageNumber=pageNumber;
			
			if(bookTemplate) raw.bookTemplate=bookTemplate.toRaw();
			
			var pgf:PrintGroupFile;
			var pgfRaw:Object;
			var arr:Array=[];
			if(files){
				for each(pgf in files){
					if(pgf){
						pgfRaw=pgf.toRaw();
						arr.push(pgfRaw);
					}
				}
			}
			raw.files=arr;
			
			return raw;
		}
		
		public static function fromRaw(raw:Object):PrintGroup{
			if(!raw) return null;
			var pg:PrintGroup= new PrintGroup();
			pg.id=raw.id;
			pg.order_id=raw.order_id;
			pg.state=raw.state;
			//pg.state_date=raw.state_date;
			pg.width=raw.width;
			pg.height=raw.height;
			pg.paper=raw.paper;
			pg.frame=raw.frame;
			pg.correction=raw.correction;
			pg.cutting=raw.cutting;
			pg.path=raw.path;
			pg.file_num=raw.file_num;
			pg.book_type=raw.book_type;
			pg.book_part=raw.book_part;
			pg.book_num=raw.book_num;
			pg.is_pdf=Boolean(raw.is_pdf);
			pg.is_duplex=Boolean(raw.is_duplex);
			pg.is_horizontal=Boolean(raw.is_horizontal);
			pg.butt=raw.butt;
			pg.pageNumber=raw.pageNumber;
			
			if(raw.hasOwnProperty('bookTemplate')) pg.bookTemplate=BookPgTemplate.fromRaw(raw.bookTemplate);
			
			var arr:Array=[];
			var pgfRaw:Object;
			var pgf:PrintGroupFile;
			if(raw.hasOwnProperty('files') && raw.files is Array){
				pg.files=new ArrayCollection(); 
				for each(pgfRaw in raw.files){
					pgf=PrintGroupFile.fromRaw(pgfRaw);
					if(pgf) pg.files.addItem(pgf);
				}
			}
			return pg; 
		}

		
		/*************** preprocess & print ***********************/
		private var _bookFiles:Array;
		//print
		private var _printFiles:Array;
		private var _pageNum:int;
		private var _pageStart:int;
		
		/**
		 * runtime max page number, use sheet_num if need pages number
		 * valid after preparePrint or direct set
		 * @return number of page in book 
		 */
		public function get pageNumber():int{
			return _pageNum;
		}
		public function set pageNumber(value:int):void{
			_pageNum=value;
		}
		
		/**
		 * valid after preparePrint
		 * @return prepared 4 print array of PrintGroupFile 
		 */
		public function get printFiles():Array{
			//TODO refactor, has to load from db
			if(!_printFiles) preparePrint();
			return _printFiles;
		}
		
		/**
		 *
		 * load PrintGroupFiles, create copies (if required)
		 *
		 */
		public function preparePrint():void{
			if(!files) return;
			_printFiles=files.toArray().concat();
		}
		
		public function get bookFiles():Array{
			if(!_bookFiles) prepareBookFiles();
			return _bookFiles;
		}
		
		public function resetBookFiles():void{
			_bookFiles=null;
		}
		
		private function prepareBookFiles():void{
			if(!files) return;
			var fa:Array=files.toArray();
			
			if(book_type==0){
				_bookFiles=fa.concat();
				return;
			}
			if(!bookTemplate) return;
			
			if(book_part==BookSynonym.BOOK_PART_COVER){
				prepareCovers();
			}else if(book_part==BookSynonym.BOOK_PART_BLOCK){
				prepareSheets();
			}else if(book_part==BookSynonym.BOOK_PART_INSERT){
				prepareInserts();
			}
		}
		
		private function detectPagesNumber():void{
			if(!files) return;
			var it:PrintGroupFile;
			_pageNum=0;
			_pageStart=int.MAX_VALUE;
			for each(it in files){
				if(it){
					_pageNum=Math.max(_pageNum,it.page_num);
					_pageStart=Math.min(_pageStart,it.page_num);
				}
			}
		}
		
		private function prepareSheets():void{
			if(!files || book_type==0 || book_part!=BookSynonym.BOOK_PART_BLOCK) return;
			var i:int;
			var j:int;
			var it:PrintGroupFile;
			var img:PrintGroupFile;
			var len:int;
			
			//detect pages num
			detectPagesNumber();
			len=_pageNum-_pageStart+1;
			
			//get default pages
			var defPages:Array=new Array();
			for each(it in files){
				if(it && it.book_num==0) defPages.push(it);
			}
			
			//fill 
			var books:Array=new Array(book_num);
			var bookFiles:Array;
			for (i=0; i<books.length; i++){
				bookFiles=new Array(len);
				//fill vs defaults
				for each(img in defPages){
					if(img){
						it=img.clone();
						it.book_num=i+1;
						bookFiles[it.page_num-_pageStart]=it;
					}
				}
				//fill vs pages
				for (j=0; j<len; j++){
					it=getImage(i+1,j+_pageStart);
					if(it) bookFiles[j]=it;
				}
				if(is_pdf && !bookTemplate.is_sheet_ready && book_type==BookSynonym.BOOK_TYPE_BOOK && is_duplex){
					//add extra blank pages
					bookFiles.unshift(null);
					bookFiles.push(null);
				}
				books[i]=bookFiles;
			}
			
			//concat 
			_bookFiles=[];
			for (i=0; i<books.length; i++){
				_bookFiles=_bookFiles.concat(books[i]);
			}
		}
		
		private function prepareCovers():void{
			if(!files || book_type==0 || book_part!=BookSynonym.BOOK_PART_COVER) return;
			var it:PrintGroupFile;
			var i:int;
			var imgFront:PrintGroupFile;
			var imgBackLeft:PrintGroupFile;
			var imgBackRight:PrintGroupFile;
			if(is_pdf && book_type==BookSynonym.BOOK_TYPE_JOURNAL && !bookTemplate.is_sheet_ready){
				//pdf journal 
				detectPagesNumber();
				_bookFiles=new Array(book_num*3);
				//default cover
				imgFront=getDefaultImage(0);
				//default 1st page
				imgBackLeft=getDefaultImage(1);
				//default last page
				imgBackRight=getDefaultImage(pageNumber);
				//fill vs defaults
				for (i=0; i<book_num; i++){
					if(imgFront){
						it=imgFront.clone();
						it.book_num=i+1;
						_bookFiles[i*3]=it;
					}
					if(imgBackLeft){
						it=imgBackLeft.clone();
						it.book_num=i+1;
						_bookFiles[i*3+1]=it;
					}
					if(imgBackRight){
						it=imgBackRight.clone();
						it.book_num=i+1;
						_bookFiles[i*3+2]=it;
					}
				}
				//fill
				for each(it in files){
					if(it && (it.page_num<2 || it.page_num==pageNumber) && it.book_num!=0){
						if(it.page_num<2){
							_bookFiles[(it.book_num-1)*3+it.page_num]=it;
						}else{
							_bookFiles[(it.book_num-1)*3+2]=it;
						}
					}
				}
			}else{
				//common
				_bookFiles=new Array(book_num);
				//fill vs default cover
				imgFront=getDefaultImage(0);
				if(imgFront){
					for (i=0; i<book_num; i++){
						it=imgFront.clone();
						it.book_num=i+1;
						_bookFiles[i]=it;
					}
				}
				//fill
				for each(it in files){
					if(it && it.page_num==0 && it.book_num!=0){
						_bookFiles[it.book_num-1]=it;
					}
				}
			}
		}
		
		private function prepareInserts():void{
			if(!files || book_type==0 || book_part!=BookSynonym.BOOK_PART_INSERT) return;
			var it:PrintGroupFile;
			var i:int;
			var imgFront:PrintGroupFile;
			var imgBackLeft:PrintGroupFile;
			var imgBackRight:PrintGroupFile;
			
			_bookFiles=new Array(book_num);
			//fill vs default cover
			imgFront=getDefaultImage(0);
			if(imgFront){
				for (i=0; i<book_num; i++){
					it=imgFront.clone();
					it.book_num=i+1;
					_bookFiles[i]=it;
				}
			}
			//fill
			for each(it in files){
				if(it && it.page_num==0 && it.book_num!=0){
					_bookFiles[it.book_num-1]=it;
				}
			}
		}
		
		private function getImage(book:int, page:int):PrintGroupFile{
			var img:PrintGroupFile;
			for each(var it:PrintGroupFile in files){
				if(it && it.book_num==book && it.page_num==page){
					img=it;
					break;
				}
			}
			return img;
		}
		
		private function getDefaultImage(page:int):PrintGroupFile{
			var img:PrintGroupFile;
			for each(var it:PrintGroupFile in files){
				if(it && it.book_num==0 && it.page_num==page){
					img=it;
					break;
				}
			}
			return img;
		}
		
		public function get pdfFileNamePrefix():String{
			var result:String='';
			if (book_type!=0 && is_pdf){
				if(book_part==BookSynonym.BOOK_PART_COVER){
					result=humanId+'-'+PDF_FILENAME_COVERS;
				}else if(book_part==BookSynonym.BOOK_PART_BLOCK){
					result=humanId+'-'+PDF_FILENAME_SHEETS;
				}
				result=SUBFOLDER_PRINT+File.separator+result;
			}
			return result;
		}
		
		public function get humanId():String{
			var arr:Array;
			var result:String='';
			if(id){
				arr=id.split('_');
				if(arr && arr.length==3) result=arr[1]+'-'+arr[2];
			}else if(order_id){
				arr=order_id.split('_');
				if(arr && arr.length==2) result=arr[1];
			}
			return result;
		}
		
		public function get orderHumanId():String{
			var arr:Array;
			var result:String='';
			if(id){
				arr=id.split('_');
				if(arr && arr.length==3) result=arr[1];
			}else if(order_id){
				arr=order_id.split('_');
				if(arr && arr.length==2) result=arr[1];
			}
			return result;
		}
		
		public function get numericId():int{
			if(!id) return 0;
			var arr:Array= id.split('_');
			var result:String='';
			if(arr && arr.length==3) result=arr[2]+arr[1];
			return result?int(result):0;
		}
		
		public function annotateText(file:PrintGroupFile):String{
			if(!file) return '';
			//id
			var txt:String=humanId;
			/*
			//book
			txt=txt+' книга '+StrUtil.lPad(file.book_num.toString(),2)+'из'+StrUtil.lPad(book_num.toString(),2);
			//sheet
			txt=txt+' разворот '+StrUtil.lPad(file.page_num.toString(),2)+'из'+StrUtil.lPad(pageNumber.toString(),2);
			//butt
			if(butt){
			txt=txt+' торец-'+butt.toString()+'мм';
			}
			*/
			txt=' '+txt+' '+file.caption+' ';
			return txt;
		}
		
		public function bookBarcodeText(file:PrintGroupFile):String{
			var sourceId:int=source_id;
			var text:String='';
			if(!sourceId && id){
				var arr:Array=id.split('_');
				if(arr && arr.length>0) sourceId=arr[0];
			}
			if(!sourceId) return '';
			var src:Source=Context.getSource(sourceId);
			if(!src) return '';
			text+=(src.code?src.code:'u');
			text+=orderHumanId;
			if(file.book_num>0){
				text=text+':'+file.book_num.toString();
			}
			return text;
		}
		
		/**
		 * 
		 * @param file
		 * @return 
		 * getDigitId+полседние 3и символа книга
		 * 2 символа источник+idзаказа+2 символа номер группы печати+3и символа книга 
		 * old: первых 2а символа источник, id, полседние 3и символа книга 
		 */		
		public function bookBarcode(file:PrintGroupFile):String{
			if(!id || !file) return '';
			/*
			var arr:Array=id.split('_');
			if(!arr || arr.length<2) return '';
			var result:String=arr[0];
			if (result.length>2) return '';
			result=StrUtil.lPad(result,2)+arr[1]+StrUtil.lPad(file.book_num.toString(),3);
			*/
			var result:String=getDigitId();
			if (result) result+=StrUtil.lPad(file.book_num.toString(),3);
			return result;
		}
		
		
		/**
		 * 
		 * @param file
		 * @return 
		 * книга(всегоКниг)-страница(всегоСтраниц) IdГруппыПечати
		 */		
		public function techBarcodeText(file:PrintGroupFile):String{
			var text:String=StrUtil.lPad(file.book_num.toString(),3)+'('+StrUtil.lPad(book_num.toString(),3)+')-'+StrUtil.lPad(file.page_num.toString(),2)+'('+StrUtil.lPad(pageNumber.toString(),2)+') '+id;
			return text;
		}
		
		/**
		 * 
		 * @param file
		 * @return 
		 * книга(3символа)всегоКниг(3символа)страница(2символа)всегоСтраниц(2символа)IdГруппыПечати(первых 2а символа источник, полседние 2а символа подгруппа) 
		 */		
		public function techBarcodeByFile(file:PrintGroupFile):String{
			/*
			var text:String=StrUtil.lPad(file.book_num.toString(),3)+StrUtil.lPad(book_num.toString(),3)
			+StrUtil.lPad(file.page_num.toString(),2)+StrUtil.lPad(pageNumber.toString(),2)
			+getDigitId();*/
			return techBarcode(file.book_num, book_num, file.page_num, pageNumber);
		}
		public function techBarcode(book:int, bookTotal:int, sheet:int, sheetTotal:int):String{
			var text:String=StrUtil.lPad(book.toString(),3)+StrUtil.lPad(bookTotal.toString(),3)
				+StrUtil.lPad(sheet.toString(),2)+StrUtil.lPad(sheetTotal.toString(),2)
				+getDigitId();
			return text;
		}
		/*
			первые 2 символа источник
			idзаказа
			последние 2 символа номер группы печати 
		*/
		private function getDigitId():String{
			if(!id) return '';
			var arr:Array=id.split('_');
			if(!arr || arr.length!=3) return '';
			var tStr:String=arr[0];
			if (tStr.length>2) return '';
			var result:String=StrUtil.lPad(tStr,2)+arr[1];
			tStr=arr[2];
			if (tStr.length>2) return '';
			return result+StrUtil.lPad(tStr,2);
		}
		
		public static function idFromDigitId(digitId:String):String{
			if(!digitId || digitId.length<5) return '';
			if(digitId.indexOf('_')!=-1) return digitId; //old barcode (x_xx_x)
			var tInt:int= parseInt(digitId.substr(0,2));
			if(isNaN(tInt)) return '';
			var result:String=tInt.toString()+'_'+digitId.substr(2,digitId.length-4);
			tInt=parseInt(digitId.substr(digitId.length-2,2));
			if(isNaN(tInt)) return '';
			return result+'_'+tInt.toString();
		}

		public static function idFromBookBarcode(code:String):String{
			if(!code || code.length<8) return '';
			if(code.indexOf('_')!=-1) return code; //old barcode (x_xx_x)
			if(code.indexOf(':')!=-1) return ''; //old barcode (x_xx_x)
			//src id
			var src:int= parseInt(code.substr(0,2));
			if(isNaN(src)) return '';
			//order id
			var order:String=code.substr(2,code.length-7);
			//pg #
			var pg:int=parseInt(code.substr(code.length-5,2));
			if(isNaN(pg)) return '';
			/*
			//book #
			var book:int=parseInt(code.substr(code.length-3,3));
			if(isNaN(book)) return '';
			*/
			return src.toString()+'_'+order+'_'+pg.toString();
		}

		public static function bookFromBookBarcode(code:String):int{
			if(!code || code.length<8) return 0;
			if(code.indexOf('_')!=-1) return 0; //old barcode (x_xx_x)
			if(code.indexOf(':')!=-1) return 0; //old barcode (x_xx_x)
			/*
			//src id
			var src:int= parseInt(code.substr(0,2));
			if(isNaN(src)) return '';
			//order id
			var order:String=code.substr(2,code.length-7);
			//pg #
			var pg:int=parseInt(code.substr(code.length-5,2));
			if(isNaN(pg)) return '';
			*/
			//book #
			var book:int=parseInt(code.substr(code.length-3,3));
			if(isNaN(book)) return 0;
			return book;
		}

    }
}